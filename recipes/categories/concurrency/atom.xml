<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Concurrency | tempus-fugit]]></title>
  <link href="http://tempusfugitlibrary.org/recipes/categories/concurrency/atom.xml" rel="self"/>
  <link href="http://tempusfugitlibrary.org/"/>
  <updated>2012-08-05T20:36:08+01:00</updated>
  <id>http://tempusfugitlibrary.org/</id>
  <author>
    <name><![CDATA[Toby Weston]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Optimise the Number of Threads]]></title>
    <link href="http://tempusfugitlibrary.org/recipes/2012/07/12/optimise-the-number-of-threads/"/>
    <updated>2012-07-12T19:01:00+01:00</updated>
    <id>http://tempusfugitlibrary.org/recipes/2012/07/12/optimise-the-number-of-threads</id>
    <content type="html"><![CDATA[<p>Working out the theoretical optimal number of threads you should use for your application is fairly straightforward. You do, however, need to understand your applications runtime characteristics. Is it mostly occupied with CPU intensive work or is it mostly waiting for IO? A <a href="http://www.yourkit.com/">good profiler</a> will help you to understand your applications profile.</p>

<!-- more -->


<h2>CPU Bound Tasks</h2>

<p>For CPU bound tasks, Goetz (2002, 2006.) recommends</p>

<pre><code>threads = number of CPUs + 1
</code></pre>

<p>Which is intuitive as if a CPU is being kept busy, we can't do more work than the number of CPUs. Goetz purports that the additional CPU has been shown as an improvement over omitting it (2006.), but others don't agree and suggest the number of CPUs is optimal.</p>

<h2>IO Bound Tasks</h2>

<p>Working out the optimal number for IO bound tasks is less obvious. During an IO bound task, a CPU will be left idle (waiting or blocking). This idle time can be better used in initiating another IO bound request.</p>

<p>Subramaniam (2011, p.31) describes the optimal number of threads in terms of the following formula.</p>

<pre><code>threads = number of cores /  (1 – blocking coefficient)
</code></pre>

<p>{% img ../../../../../images/subramaniam.gif %}</p>

<p>And Goetz (2002) describes the optimal number of threads in terms of the following.</p>

<pre><code>threads = number of cores * (1 + wait time / service time)
</code></pre>

<p>{% img ../../../../../images/goetz.gif %}</p>

<p>Where we can think of <code>wait time / service</code> time as a measure of how contended the task is.</p>

<h2>Goetz and Subramaniam Agree</h2>

<p>Just out of interest, we can show that both IO bound formulas are equivalent. Starting with Goetz’s formula, we assert that <code>w+s=1</code> and remove the service time (<code>s</code>) giving the following</p>

<p>{% img ../../../../../images/goetz-2.gif %}</p>

<p>We can continue by multiplying both sides by <code>1-w</code> reducing the right hand side to <code>c</code> before reversing the operation and revealing Subramaniam’s expression.</p>

<p>{% img ../../../../../images/goetz-3.gif %}</p>

<p>{% img ../../../../../images/goetz-4.gif %}</p>

<p>{% img ../../../../../images/subramaniam.gif %}</p>

<p>Thanks to <a href="https://twitter.com/Jazzatola">Jazzatola</a> for mathematical input.</p>

<h2>References</h2>

<ul>
<li>Goetz, B. 2002. <a href="http://www.ibm.com/developerworks/java/library/j-jtp0730/index.html">Java theory and practice: Thread pools and work queues</a>. IBM DeveloperWorks.</li>
<li>Goetz, B. Peierls, T. Bloch, J. Bowbeer, J. Holmes, D. and Lea, D. 2006. <a href="http://amzn.to/NrXQPZ">Java Concurrency in Practice</a>. 1st Edition. Addison Wesley.</li>
<li>Subramaniam, V. 2011. <a href="http://amzn.to/NrXXuI">Programming Concurrency on the JVM</a>. 1st Edition. Pragmatic Bookshelf.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling Interrupt Exceptions]]></title>
    <link href="http://tempusfugitlibrary.org/recipes/2012/06/30/handling-interrupt-exceptions/"/>
    <updated>2012-06-30T13:01:00+01:00</updated>
    <id>http://tempusfugitlibrary.org/recipes/2012/06/30/handling-interrupt-exceptions</id>
    <content type="html"><![CDATA[<p>How should you handle <code>InterruptedException</code>s?</p>

<p>{% codeblock lang:java %}
try {</p>

<pre><code>Thread.sleep(100);
</code></pre>

<p>} catch (InterruptedException e) {</p>

<pre><code>// what to do?
</code></pre>

<p>}
{% endcodeblock %}</p>

<!-- more -->


<p>You could rethrow if it's appropriate but often its not. If that's the case, you should set the <em>interrupt status</em> flag associated with the current thread. For example,</p>

<p>{% codeblock lang:java %}
try {</p>

<pre><code>Thread.sleep(100);
</code></pre>

<p>} catch (InterruptedException e) {</p>

<pre><code>Thread.currentThread().interrupt(); // reset the interrupt status
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Typically, if a Java method throws <code>InterruptedException</code>, it will have reset the <em>interrupt status</em> before doing so. In the example above, you're just restoring it and preserving a flag to indicate the thread had once been interrupted.</p>

<p>The reason for preserving this status flag is in case code other than your own depends on it. For example, a framework (which you may not appreciate is actually being used), may be doing something like the following to (correctly) support interruption.</p>

<p>{% codeblock lang:java %}
while (!Thread.currentThread().isInterrupted()) {</p>

<pre><code>process();
</code></pre>

<p>}{% endcodeblock %}</p>

<p>You should generally never just catch the exception and ignore it; it may cripple code depending on the status flag for correct behaviour. In the same way, it's rarely a good idea to catch and exception and <a href="http://baddotrobot.com/blog/2010/10/18/logging-is-evil-but/">just log it</a>, especially in the case of <code>InterruptedException</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Avoid JMock Finaliser Problems]]></title>
    <link href="http://tempusfugitlibrary.org/recipes/2012/06/01/avoid-jmock-finaliser-problems/"/>
    <updated>2012-06-01T23:22:00+01:00</updated>
    <id>http://tempusfugitlibrary.org/recipes/2012/06/01/avoid-jmock-finaliser-problems</id>
    <content type="html"><![CDATA[<p>The default threading policy for a JMock <code>Mockery</code> warns if the mockery is being used by multiple threads. The <code>SingleThreadedPolicy</code> will output the following.</p>

<pre><code>2012-05-31 07:35:35 ERROR Finalizer [Console$Logger] - the Mockery is not thread-safe: use a Synchroniser to ensure thread safety
</code></pre>

<p>If you really need multi-threaded access to the mockery, it's a <a href="/recipes/2012/06/01/making-jmock-thread-safe">straight forward fix</a> to swap the policy out. As in the log line above though, sometimes the JVM's finaliser thread sticks it's oar in and confuses the <code>SingleThreadedPolicy</code>.</p>

<!-- more -->


<p>To get rid of this, you can set a custom threading policy that performs the same check as the default, just not when the finaliser thread is involved.</p>

<p>{% codeblock lang:java %}
{% assign braces = '{{' %}
private final Mockery context = new Mockery() {{ braces }}</p>

<pre><code>setThreadingPolicy(new SingleThreadedPolicyAvoidingFinaliseProblems());
</code></pre>

<p>}};
{% endcodeblock %}</p>

<p>{% codeblock lang:java %}
public static class SingleThreadedPolicyAvoidingFinaliseProblems extends SingleThreadedPolicy {</p>

<pre><code>@Override
public Invokable synchroniseAccessTo(Invokable unsynchronizedInvocation) {
    Invokable synchronizedInvocation = super.synchroniseAccessTo(unsynchronizedInvocation);
    return new InvokeBasedOnCurrentThreadBeingTheFinalizerThread(unsynchronizedInvocation, synchronizedInvocation);
}
</code></pre>

<p>}</p>

<p>private static class InvokeBasedOnCurrentThreadBeingTheFinalizerThread implements Invokable {</p>

<pre><code>private final Invokable whenOnFinalizerThread;
private final Invokable whenNotFinalizerThread;

public InvokeBasedOnCurrentThreadBeingTheFinalizerThread(Invokable whenOnFinalizerThread, Invokable whenNotFinalizerThread) {
    this.whenOnFinalizerThread = whenOnFinalizerThread;
    this.whenNotFinalizerThread = whenNotFinalizerThread;
}

@Override
public Object invoke(Invocation invocation) throws Throwable {
    if (currentThreadIs("Finalizer"))
        return whenOnFinalizerThread.invoke(invocation);
    return whenNotFinalizerThread.invoke(invocation);
}

private static boolean currentThreadIs(String name) {
    return Thread.currentThread().getName().equalsIgnoreCase(name);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>See the bug report <a href="http://jira.codehaus.org/browse/JMOCK-256">JMOCK-256</a> for more details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Timeout in JMock Synchroniser]]></title>
    <link href="http://tempusfugitlibrary.org/recipes/2012/06/01/timeout-jmock-synchroniser/"/>
    <updated>2012-06-01T21:15:00+01:00</updated>
    <id>http://tempusfugitlibrary.org/recipes/2012/06/01/timeout-jmock-synchroniser</id>
    <content type="html"><![CDATA[<p>JMock's <code>Synchroniser</code> serialises access to the mock object's "context", it means all invocations of mocked methods call will be <code>synchronized</code> on the same monitor, effectively forcing them to run in sequence without thread safety concerns. As it uses <code>synchronized</code> though, you can (with some effort) get into trouble with tests that never finish.</p>

<p>If you're seeing this kind of thing, apart from using the <code>@Test(timeout=1000)</code> annotation, you might consider an alternative <code>ThreadingPolicy</code> implementation using <code>Lock</code>s that can timeout and maintain liveliness.</p>

<!-- more -->


<p>{% codeblock lang:java %}</p>

<p>public class TimingOutSynchroniser implements ThreadingPolicy {</p>

<pre><code>private final Lock lock = new ReentrantLock();
private final Condition awaitingStatePredicate = lock.newCondition();
private final Duration lockTimeout;

private Error firstError = null;

public TimingOutSynchroniser() {
    this(millis(250));
}

public TimingOutSynchroniser(Duration timeout) {
    this.lockTimeout = timeout;
}

public void waitUntil(StatePredicate predicate) throws InterruptedException {
    waitUntil(predicate, new InfiniteTimeout());
}

/**
 * Waits up to a timeout for a StatePredicate to become active.  Fails the
 * test if the timeout expires.
 */
public void waitUntil(StatePredicate predicate, long timeoutMs) throws InterruptedException {
    waitUntil(predicate, new FixedTimeout(timeoutMs));
}

private void waitUntil(StatePredicate predicate, Timeout testTimeout) throws InterruptedException {
    try {
        lock.tryLock(lockTimeout.inMillis(), MILLISECONDS);
        while (!predicate.isActive()) {
            try {
                awaitingStatePredicate.await(testTimeout.timeRemaining(), MILLISECONDS);
            } catch (TimeoutException e) {
                if (firstError != null)
                    throw firstError;
                Assert.fail("timed out waiting for " + asString(predicate));
            }
        }
    } finally {
        if (lock.tryLock())
            lock.unlock();
    }

}

public Invokable synchroniseAccessTo(final Invokable mockObject) {
    return new Invokable() {
        public Object invoke(Invocation invocation) throws Throwable {
            return synchroniseInvocation(mockObject, invocation);
        }
    };
}

private Object synchroniseInvocation(Invokable mockObject, Invocation invocation) throws Throwable {
    try {
        lock.tryLock(lockTimeout.inMillis(), MILLISECONDS);
        try {
            return mockObject.invoke(invocation);
        } catch (Error e) {
            if (firstError == null)
                firstError = e;
            throw e;
        } finally {
            awaitingStatePredicate.signalAll();
        }
    } finally {
        if (lock.tryLock())
            lock.unlock();
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make JMock Thread Safe]]></title>
    <link href="http://tempusfugitlibrary.org/recipes/2012/06/01/making-jmock-thread-safe/"/>
    <updated>2012-06-01T19:00:00+01:00</updated>
    <id>http://tempusfugitlibrary.org/recipes/2012/06/01/making-jmock-thread-safe</id>
    <content type="html"><![CDATA[<p>By default, JMock's "context" is not thread safe. All bets are off if you access the <code>Mockery</code> from  multiple threads. Happily, since JMock 2.6.0, you can set a threading policy per mockery.</p>

<p>{% codeblock lang:java %}
{% assign braces = '{{' %}
Mockery mockery = new JUnit4Mockery() {{ braces }}</p>

<pre><code>setThreadingPolicy(new Synchroniser());
</code></pre>

<p>}};{% endcodeblock %}</p>

<p>The <code>Synchroniser</code> forces serialisation of each mocked method call using <code>synchronized</code>. Use it when you're running multi-threaded style tests using JMock. The default behaviour will warn you if a mockery is being used like this.</p>

<pre><code>the Mockery is not thread-safe: use a Synchroniser to ensure thread safety
</code></pre>
]]></content>
  </entry>
  
</feed>
