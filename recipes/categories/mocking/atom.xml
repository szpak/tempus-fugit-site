<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mocking | tempus-fugit]]></title>
  <link href="http://tempusfugitlibrary.org/recipes/categories/mocking/atom.xml" rel="self"/>
  <link href="http://tempusfugitlibrary.org/"/>
  <updated>2012-08-05T20:36:08+01:00</updated>
  <id>http://tempusfugitlibrary.org/</id>
  <author>
    <name><![CDATA[Toby Weston]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Avoid JMock Finaliser Problems]]></title>
    <link href="http://tempusfugitlibrary.org/recipes/2012/06/01/avoid-jmock-finaliser-problems/"/>
    <updated>2012-06-01T23:22:00+01:00</updated>
    <id>http://tempusfugitlibrary.org/recipes/2012/06/01/avoid-jmock-finaliser-problems</id>
    <content type="html"><![CDATA[<p>The default threading policy for a JMock <code>Mockery</code> warns if the mockery is being used by multiple threads. The <code>SingleThreadedPolicy</code> will output the following.</p>

<pre><code>2012-05-31 07:35:35 ERROR Finalizer [Console$Logger] - the Mockery is not thread-safe: use a Synchroniser to ensure thread safety
</code></pre>

<p>If you really need multi-threaded access to the mockery, it's a <a href="/recipes/2012/06/01/making-jmock-thread-safe">straight forward fix</a> to swap the policy out. As in the log line above though, sometimes the JVM's finaliser thread sticks it's oar in and confuses the <code>SingleThreadedPolicy</code>.</p>

<!-- more -->


<p>To get rid of this, you can set a custom threading policy that performs the same check as the default, just not when the finaliser thread is involved.</p>

<p>{% codeblock lang:java %}
{% assign braces = '{{' %}
private final Mockery context = new Mockery() {{ braces }}</p>

<pre><code>setThreadingPolicy(new SingleThreadedPolicyAvoidingFinaliseProblems());
</code></pre>

<p>}};
{% endcodeblock %}</p>

<p>{% codeblock lang:java %}
public static class SingleThreadedPolicyAvoidingFinaliseProblems extends SingleThreadedPolicy {</p>

<pre><code>@Override
public Invokable synchroniseAccessTo(Invokable unsynchronizedInvocation) {
    Invokable synchronizedInvocation = super.synchroniseAccessTo(unsynchronizedInvocation);
    return new InvokeBasedOnCurrentThreadBeingTheFinalizerThread(unsynchronizedInvocation, synchronizedInvocation);
}
</code></pre>

<p>}</p>

<p>private static class InvokeBasedOnCurrentThreadBeingTheFinalizerThread implements Invokable {</p>

<pre><code>private final Invokable whenOnFinalizerThread;
private final Invokable whenNotFinalizerThread;

public InvokeBasedOnCurrentThreadBeingTheFinalizerThread(Invokable whenOnFinalizerThread, Invokable whenNotFinalizerThread) {
    this.whenOnFinalizerThread = whenOnFinalizerThread;
    this.whenNotFinalizerThread = whenNotFinalizerThread;
}

@Override
public Object invoke(Invocation invocation) throws Throwable {
    if (currentThreadIs("Finalizer"))
        return whenOnFinalizerThread.invoke(invocation);
    return whenNotFinalizerThread.invoke(invocation);
}

private static boolean currentThreadIs(String name) {
    return Thread.currentThread().getName().equalsIgnoreCase(name);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>See the bug report <a href="http://jira.codehaus.org/browse/JMOCK-256">JMOCK-256</a> for more details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Timeout in JMock Synchroniser]]></title>
    <link href="http://tempusfugitlibrary.org/recipes/2012/06/01/timeout-jmock-synchroniser/"/>
    <updated>2012-06-01T21:15:00+01:00</updated>
    <id>http://tempusfugitlibrary.org/recipes/2012/06/01/timeout-jmock-synchroniser</id>
    <content type="html"><![CDATA[<p>JMock's <code>Synchroniser</code> serialises access to the mock object's "context", it means all invocations of mocked methods call will be <code>synchronized</code> on the same monitor, effectively forcing them to run in sequence without thread safety concerns. As it uses <code>synchronized</code> though, you can (with some effort) get into trouble with tests that never finish.</p>

<p>If you're seeing this kind of thing, apart from using the <code>@Test(timeout=1000)</code> annotation, you might consider an alternative <code>ThreadingPolicy</code> implementation using <code>Lock</code>s that can timeout and maintain liveliness.</p>

<!-- more -->


<p>{% codeblock lang:java %}</p>

<p>public class TimingOutSynchroniser implements ThreadingPolicy {</p>

<pre><code>private final Lock lock = new ReentrantLock();
private final Condition awaitingStatePredicate = lock.newCondition();
private final Duration lockTimeout;

private Error firstError = null;

public TimingOutSynchroniser() {
    this(millis(250));
}

public TimingOutSynchroniser(Duration timeout) {
    this.lockTimeout = timeout;
}

public void waitUntil(StatePredicate predicate) throws InterruptedException {
    waitUntil(predicate, new InfiniteTimeout());
}

/**
 * Waits up to a timeout for a StatePredicate to become active.  Fails the
 * test if the timeout expires.
 */
public void waitUntil(StatePredicate predicate, long timeoutMs) throws InterruptedException {
    waitUntil(predicate, new FixedTimeout(timeoutMs));
}

private void waitUntil(StatePredicate predicate, Timeout testTimeout) throws InterruptedException {
    try {
        lock.tryLock(lockTimeout.inMillis(), MILLISECONDS);
        while (!predicate.isActive()) {
            try {
                awaitingStatePredicate.await(testTimeout.timeRemaining(), MILLISECONDS);
            } catch (TimeoutException e) {
                if (firstError != null)
                    throw firstError;
                Assert.fail("timed out waiting for " + asString(predicate));
            }
        }
    } finally {
        if (lock.tryLock())
            lock.unlock();
    }

}

public Invokable synchroniseAccessTo(final Invokable mockObject) {
    return new Invokable() {
        public Object invoke(Invocation invocation) throws Throwable {
            return synchroniseInvocation(mockObject, invocation);
        }
    };
}

private Object synchroniseInvocation(Invokable mockObject, Invocation invocation) throws Throwable {
    try {
        lock.tryLock(lockTimeout.inMillis(), MILLISECONDS);
        try {
            return mockObject.invoke(invocation);
        } catch (Error e) {
            if (firstError == null)
                firstError = e;
            throw e;
        } finally {
            awaitingStatePredicate.signalAll();
        }
    } finally {
        if (lock.tryLock())
            lock.unlock();
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make JMock Thread Safe]]></title>
    <link href="http://tempusfugitlibrary.org/recipes/2012/06/01/making-jmock-thread-safe/"/>
    <updated>2012-06-01T19:00:00+01:00</updated>
    <id>http://tempusfugitlibrary.org/recipes/2012/06/01/making-jmock-thread-safe</id>
    <content type="html"><![CDATA[<p>By default, JMock's "context" is not thread safe. All bets are off if you access the <code>Mockery</code> from  multiple threads. Happily, since JMock 2.6.0, you can set a threading policy per mockery.</p>

<p>{% codeblock lang:java %}
{% assign braces = '{{' %}
Mockery mockery = new JUnit4Mockery() {{ braces }}</p>

<pre><code>setThreadingPolicy(new Synchroniser());
</code></pre>

<p>}};{% endcodeblock %}</p>

<p>The <code>Synchroniser</code> forces serialisation of each mocked method call using <code>synchronized</code>. Use it when you're running multi-threaded style tests using JMock. The default behaviour will warn you if a mockery is being used like this.</p>

<pre><code>the Mockery is not thread-safe: use a Synchroniser to ensure thread safety
</code></pre>
]]></content>
  </entry>
  
</feed>
